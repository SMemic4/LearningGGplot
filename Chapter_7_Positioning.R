library(tidyverse)
library(mapproj)

###############################################################################################################################################################################################
# Chapter 7: Positioning
###############################################################################################################################################################################################
# 7.1 Introduction
###############################################################################################################################################################################################
# There are four components that control positions:
# 1. Position adjustments adjust the position of overlapping objects within a layer. This is useful for bar and other interval geoms, but can be useful in other situations
# 2. Position scales control how the values in the data are mapped to positions on the plot
# 3. Faceting is a mechanism for automatically laying out multiple plots on a page. It splits the data into subsets, and the plots each subset in a different panel. Such plots are called small multipes or trellis graphics
# 4. Coordinate systems control how the two independent position scales are combined to create a 2d coordinate system. The most common coordinate system is Cartesian, but other coordinate systems can be useful in special circumstances

###############################################################################################################################################################################################
# 7.2 Faceting
###############################################################################################################################################################################################
# Faceting generates small multiples each showing a different subset of the data. 
# Small multiples are useful for exploratory data analysis. They allow for the rapid comparison of patterns in different parts of the data

# There are three different types of faceting:
# 1. facet_null() - A single plot, the default
# 2. facet_wrap() - "Wraps" a 1d ribbon of panels into 2d
# 3. facet_grid() Produces a 2d grid of panels defined by variables which form the rows and columns

# Faceted plots have the capability to fill up a lot of space, so it's easier to use a subset of the data that has a manageable number of levels

mpg2 <- subset(mpg, cyl !=5 & drv %in% c("4", "f") & class != "2seater")

###############################################################################################################################################################################################
# 7.2.1 Facet Wrap
###############################################################################################################################################################################################
# Facet_wrap() makes a long ribbon of panels (generated by any number of variables) and wraps it into 2d. 
# This is useful if the data contains a single variable with many levels and needs to be arranged in a space efficient manner

# The wrapping of the ribbon onto the grid can be controlled with ncol, nrow, as.table and dir.
# ncol and nrow control how many columns and rows (only one needs to be set) appear
# as.table controls whether the facets are laid out like a table (TRUE), with the highest values at the bottom-right, or a plot (FALSE) with the highest values at the top-right
# dir controls the direction of wrap horizontal or vertical

base <- ggplot(mpg2, aes(displ, hwy)) + 
  geom_blank() +
  xlab(NULL) +
  ylab(NULL)

base + facet_wrap(~class, ncol = 3) # A facet wrapped plot with 3 columns. Each column contains 2 variables since there are 6 total types of class variables
base + facet_wrap(~class, ncol = 3, as.table = FALSE)  # Changes the order which the variables appear
base + facet_wrap(~class, nrow = 3) # A facet plot that contains 3 rows
base + facet_wrap(~class, nrow = 3, dir = "v") # Changes the order of the plots since the direction of the wrapping was changed

###############################################################################################################################################################################################
# 7.2.2 Facet Grid
###############################################################################################################################################################################################
# facet_grid() lays out plots in a 2d grid, as defined by a formula:
# .~var spreads the values of "var" across the columns. The direction facilitates comparisons of y position, because the vertical scales are aligned

base + facet_grid(.~cyl) # A facet plot with all of the levels of "cyl". There are three columns because it is comparing the vertical scales of the variables

# var.~ spreads the values of "var" down the rows. This direction facilitates the comparison of x position because the horizontal scales are aligned. This make it useful for comparing distributions

base + facet_grid(drv ~.) # A facet plot with all of the levels of "drv". It is one column with 2 rows since this drv contains two levels. They are aligned the y axis

# var1 ~. var2 spreads "var1" across columns and "var2" down rows. The variable with the greatest number of levels should be placed in the columns to take advantage of the aspect ratio of a screen

base + facet_grid(drv ~ cyl) # A facet plot with 3 columns and 2 rows

# Multiple variables in the rows or columns can be added together "a + b ~ c + d". Variables appearing together on the rows or columns are nested in the sense that only combinations that appear in the data will appear in the plot
# Variables that are specified on rows and columns will be crossed: all combinations will be shown including those that didn't appear in the original dataset: this may result in empty panels

###############################################################################################################################################################################################
# 7.2.3 Controlling Scales
###############################################################################################################################################################################################
# For both facet_wrap() and facet_grid() the position of the scales can be altered so the scales are the same (fixed) or varied between panels (free) with the scales parameter:
# scales = "fixed": x and y scales are fixed across all panels
# scales = "free_x": the x scale is free while the y scale is fixed
# scales = "free_y": the y scale is free while the x scale is fixed
# scales = "free": x and y scales vary across panels

# facet_grid() imposes an additional constraint on the scales: all panels in a column must have the same x scale, and all panels in a row must have the same y scale. This is because each column shares an x axis, and each row shares a y axis

# Fixed scales make it easier to see patterns across panels; free scales make it easier to see patterns within panels

p <- ggplot(mpg2, aes(cty, hwy)) + geom_abline() + geom_jitter(width = 0.1, height = 0.1)

p + facet_wrap(~cyl)

p + facet_wrap(~cyl, scales = "free")

# Free scales are useful for displaying multiple time series that were measured on different scales
# To do this the data has to be changed from "wide" to "long" data, stacking the separate variables into a single column

economics_long

ggplot(economics_long, aes(date, value)) + geom_line() + facet_wrap(~ variable, scales = "free_y", ncol = 1)

# facet_grid() has an additional parameter called space, which takes the same values as scales. When space is "free", each column (or row) will have width (or height) proportional to the range of the scale for that column ( or row)
# This makes the scaling equal across the whole plot. This is most useful for categorical scales where space can be assigned proportionally based on the number of levels in each facet. 

mpg2$model <- reorder(mpg2$model, mpg2$cty)
mpg2$manufacturer <- reorder(mpg2$manufacturer, -mpg2$cty)
ggplot(mpg2, aes(cty, model)) +
  geom_point() +
  facet_grid(manufacturer~. , scales = "free", space = "free") +
  theme(strip.text.y = element_text(angle = 0))

###############################################################################################################################################################################################
# 7.2.4 Missing Faceting Variables
###############################################################################################################################################################################################
# When faceting a plot with multiple datasets, occasionally some of the datasets may be missing a faceting variable. 
# GGplot will display the map in every facet: missing faceting variables are treated like they have all values

df1 <- data.frame(x = 1:3, y = 1:3, gender = c("f", "f", "m"))
df2 <- data.frame(x = 2, y = 2)

ggplot(df1, aes(x, y)) + geom_point(data = df2, color = "red", size = 2) + geom_point() + facet_wrap(~gender)

# This technique is useful when adding annotations to make it easier to compare between facets

###############################################################################################################################################################################################
# 7.2.5 Grouping vs. Faceting 
###############################################################################################################################################################################################
# Faceting is an alternative to using aesthetics (like color, shape, or size) to differentiate groups. Both techniques have their strengths and weaknesses
# With faceting each group is own it's own with no overlap with the other groups. This is useful for when groups overlap each other a lot, but makes it harder to make out smaller differences between the two
# When grouping by aesthetics, the groups may overlap but it becomes easier to see smaller differences between the different groups

df <- data.frame(
  x = rnorm(120, c(0, 2, 4)),
  y = rnorm(120, c(1, 2, 1)),
  z = letters[1:3]
)

ggplot(df, aes(x,y)) + geom_point(aes(color = z)) # Scatterplot with the different groups labeled a separate color
ggplot(df, aes(x,y)) + geom_point() + facet_wrap(~z) # Facet wrap of the different groups

# Comparisons between facets often benefit through useful annotations

df_sum <- df %>% group_by(z) %>% summarize(x = mean(x), y = mean(y)) %>% rename(z2 = z)
ggplot(df, aes(x, y)) + geom_point() + geom_point(data = df_sum, aes(color = z2), size = 4) + facet_wrap(~z)

#Another useful technique is placing all of the data in the background of each panel

df2 <- select(df, -z)

ggplot(df, aes(x,y)) +geom_point(data = df2, color = "grey50") + geom_point(aes(color = z)) + facet_wrap(~z) # A facet wrapped plot that contains all of the points for each facet but each column has it's specific group highlighted in it's color

###############################################################################################################################################################################################
# 7.2.6 Continuous Variables
###############################################################################################################################################################################################
# To facet continuous variables, they must be discretized. GGplot2 provides three helper functions to achieve this:
# 1. Divide the data into n bins each of the same length with cut_interval(x,n)
# 2. Divide the data into bins of width: cut_width(x, width)
# 3. Divide the data into n bins containing (approximately the same number of points): cut_number(x, n = 10)

mpg2$disp_w <- cut_width(mpg2$displ, 1) # Bins of width 1
mpg2$disp_i <- cut_interval(mpg2$displ, 6) # Six bins of equal length
mpg2$disp_n <- cut_number(mpg2$displ, 6) # Six bins containing equal numbers of points

plot <- ggplot(mpg2, aes(cty, hwy)) + geom_point() + labs(x = NULL, y = NULL)

plot + facet_wrap(~disp_w, nrow = 1)
plot + facet_wrap(~disp_i, nrow = 1)
plot + facet_wrap(~disp_n, nrow = 1)

# Note that the faceting formula does not evaluate functions, so they must first be created as a new variable containing the discreteised data. 

###############################################################################################################################################################################################
# 7.2.7 Exercises
###############################################################################################################################################################################################
# 1. Diamonds: display the distribution of price conditional on cut and carat. Try faceting by cut and grouping by carat. Try faceting by carat and grouping by cut. Which is preferred?

ggplot(diamonds, aes(x = carat, y = price)) + geom_point() + facet_wrap(~cut)

ggplot(diamonds, aes(x = price)) + geom_histogram(aes(fill = cut)) 

# 2. Why is facet_wrap() generally more useful than facet_grid()

# Facet_wrap wraps a 1d sequence of panels into 2d. This is generally a better use of screen space than facet_grid() due to most grids being roughly rectangular

# 3. Recreate the following plot. It facets mpg2 by class, overlaying a smooth curve fit to the full dataset

ggplot(mpg2, aes(displ, hwy)) + geom_point() + geom_smooth(data = select(mpg2, -class), se = FALSE) + facet_wrap(~class)

###############################################################################################################################################################################################
# 7.3 Coordinate Systems
###############################################################################################################################################################################################
# Coordinate systems have two main jobs
# 1. Combine the two position aesthetics to produce a 2d position on the plot. The position aesthetics are called x and y but may be called something else depending on the coordinate system
# 2. In coordinate with the facter, coordinate systems draw axes and panel backgrounds. While the scales control the values that appear on the axes, and how they map from data to position, it is the coordinate system that actually draws them

# There are two types of coordinate systems. Linear coordinates system preserve the shape of geoms:
# coord_Cartesian(): The default Cartesian coordinate system, where the 2d position of an element is given by the combination of the x and y positions
# coord_flip(): Cartesian coordinate system with x and y axes flipped
# coord_fixed(): Cartesian coordinate system with a fixed aspect ratio

# Non-linear coordinate system can change the shapes: a straight line may no longer be straight. The closest distance between two points may no longer be a line
# coord_map()/coord_quickmap() - Map projections
# coord_polar(): Polar coordinates
# coord_trans(): Apply arbitrary transformations to x and y positions after the data has been processed by the stat

###############################################################################################################################################################################################
# 7.4 Linear Coordinate Systems
###############################################################################################################################################################################################
# There are three linear coordinate systems:
# 1. coord_Cartesian()
# 2. coord_flip()
# 3. coord_fixed()

###############################################################################################################################################################################################
# 7.4.1 Zooming into a Plot with coord_Cartesian()
###############################################################################################################################################################################################
# coord_Cartesian() has arguments xlim and ylim. This allows for only a small region of the data to be displayed without discarding any other data

base <- ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_smooth()

base # Full dataset

base + scale_x_continuous(limits = c(5,7)) # Scaling to 5-7 throws away all data outside this range
base + coord_cartesian(xlim = c(5,7)) # Zooms in on this data without removing it. Notice how the geom_smooth() changes when data is removed

###############################################################################################################################################################################################
# 7.4.2 Flipping the Axes with coord_flip()
###############################################################################################################################################################################################
# coord_flip() can be used to exchange the x and y axes

ggplot(mpg, aes(displ, cty)) + geom_point() + geom_smooth() # Original data
ggplot(mpg, aes(cty, displ)) + geom_point() + geom_smooth() # Changing the axes alters the data
ggplot(mpg, aes(displ, cty)) + geom_point() + geom_smooth() + coord_flip() # Fits to the original data and than rotates the output

###############################################################################################################################################################################################
# 7.4.3 Equal Scales with coord_fixed()
###############################################################################################################################################################################################
# Coord_fixed() fixes the ratio of length on the x and y axes. The default ratio ensures that the x and y axes have equal scale.

###############################################################################################################################################################################################
# 7.5 Non-linear Coordinate Systems
###############################################################################################################################################################################################
# Non-linear coordinates can change the shape of geoms
# For example, in polar coordinates a rectangle becomes an arc, in a map projection, the shortest path between two points is not necessarily a straight line

rect <- data.frame(x = 50, y = 50)
line <- data.frame(x = c(1, 200), y = c(100, 1))
base <- ggplot(mapping = aes(x, y)) +
  geom_tile(data = rect, aes(width = 50, height = 50)) +
  geom_line(data = line) + 
  xlab(NULL) + ylab(NULL)

base
base + coord_polar("x") # The line is curved and the rectangle has become an arc
base + coord_polar("y") # Line is curved, and the square has become "U-shaped"
base + coord_flip() # Flips x and y coordinates
base + coord_trans(y = "log10") # Applies a log10 transformation to the y axis after the statistical calculations have been completed
base + coord_fixed() # Scales the graph

# Transformation takes part in two steps
# First, the parameterisation of each geom is changed to be purely location-based, rather than location and dimension-based. 
# For example, a bar can be represented as ab x position (a location), a height and a width (dimensions)
# Interpreting height and width in a non-Cartesian coordinate system is hard because a rectangle may no longer have constant height and width, so it's converted to a purely location based representation, a poly gon defined by the four corners
# This effectively converts all geoms to a combination of points, lines, and polygons
# Secondly, after all geoms have a location based representation, the next step is transforming each location into the new coordinate system.
# It is easy to transform points, because a point is still a point no matter the coordinate system
# Lines and polygons are harder, because a straight line may no longer be straight in the new coordinate system
# To circumvent this issue, it is assumed that all lines will by broken into many small line segments and transformed for each segment
# This process is called munching: 

# First, start with a line parameterised by two endpoints

df <- data.frame(r = c(0,1), theta = c(0, 3/2 * pi))
ggplot(df, aes(r, theta)) + geom_line() + geom_point(size = 2, color = "red") # A line with two end points

# Second, break it into multiple line segments, each with two endpoints

intrep <- function(rng, n) # Function that breaks up a line into n segments
{
  seq(rng[1], rng[2], length = n)
}

munched <- data.frame(r = intrep(df$r, 15), theta = intrep(df$theta, 15)) # Creating the new data set

ggplot(munched, aes(r, theta)) + geom_line() + geom_point(size = 2, color = "red") # Small line as on the graph but broken down into smaller points

# Finally, transform the locations of each piece

transformed <- transform(munched, x = r * sin(theta), y = r * cos(theta))
ggplot(transformed, aes(x, y)) + geom_path() + geom_point(size = 2, color = "red") + coord_fixed()

# Internally ggplot2, uses many more segments so that the results look smooth

###############################################################################################################################################################################################
# 7.5.1 Transformations with coord_trans()
###############################################################################################################################################################################################
# Like limits, data can be transformed in two places, at the scale level or at the coordinate system
# coord_trans() has has arguments x and y which should be strings naming the transformer or transformer objects
# Transforming at the scale level occurs before statistics are computed, and does not change the shape of the geom
# Transforming at the coordinate system level occurs after the statistics have been computed and does affect the shape of the geom
# Using both together allows for data to be model on a transformed scale and then back transformed for interpretation

# Linear model on the this original scale is a poor fit
base <- ggplot(diamonds, aes(carat, price)) + 
  stat_bin2d() +
  geom_smooth(method = "lm") +
  xlab(NULL) +
  ylab(NULL) +
  theme(legend.position = "none")
  

base + scale_x_log10() + scale_y_log10() # Better fit on the scale, but much harder to interpret

pow10 <- scales::exp_trans(10)

base + scale_x_log10() + scale_y_log10() + coord_trans(x = pow10, y = pow10)# Fits on log scale, then back transform to original. Highlights the lack of expensive diamonds with large carats

###############################################################################################################################################################################################
# 7.5.2 Polar Coordinates with coord_polar()
###############################################################################################################################################################################################
# Using polar coordinates gives rise to pie charts and wind roses (from bar charts), and radar charts ( from line geoms)
# Polar coordinates are often used for circular data, particularly time or direction, but the perceptual properties are not good because the angle is harder to perceive for small radii than it is for large radii
# The following good transforms a bar chart into a pie chart or bullseye chart by changing the coordinate system

base <- ggplot(mtcars, aes(factor(1), fill = factor(cyl))) + geom_bar(width = 1) + theme(legend.position = "none") +
  scale_x_discrete(NULL, expand = c(0,0)) +
  scale_y_continuous(NULL, expand = c(0,0))
base # Stacked bar chart

base + coord_polar(theta = "y") # Pie chart

base + coord_polar() # Bullseye chart

###############################################################################################################################################################################################
# 7.5.3 Map Projections with coord_map()
###############################################################################################################################################################################################
# Maps are intrinsically displays of spherical data. Simply plotting raw longitudes and latitudes is misleading, so the data must be projected
# There are two ways to do this

# 1. coord_quickmap() is a quick and dirty approximation that sets the aspect ratio to ensure that 1m of latitude and 1m of longitude are the same distance in the middle of the plot. This is reasonable for smaller regions and is much faster

# Creating a map of NZ

nzmap <- ggplot(map_data("nz"), aes(long, lat, group = group)) + 
  geom_polygon(fill = "white", color = "black") + 
  xlab(NULL) + ylab(NULL)

nzmap # Plotted in Cartesian coordinates

nzmap + coord_quickmap() # With aspect ratio approximation

# coord_map() uses the mapproj package, to do formal map projections. It takes the same arguments as mapproj::mapproject() for controlling the projection
# It is much slower than coord_quickmap() because it munchs the data and transforms each piece

world <- map_data("world")
worldmap <- ggplot(world, aes(long, lat, group = group)) +
  geom_path() +
  scale_y_continuous(NULL, breaks = (-2:3) * 30, labels = NULL) + 
  scale_x_continuous(NULL, breaks = (-4:4) * 45, labels = NULL)

worldmap + coord_map()
worldmap + coord_map("ortho")
worldmap + coord_map("stereographic")

###############################################################################################################################################################################################
# End of Chapter 8
###############################################################################################################################################################################################




